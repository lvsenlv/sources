为了提高效率，计算机从内存中取数据是按照一个固定长度的。
以32位机为例，它每次取32个位，也就是4个字节,也就是说1个int的数据全部落在计算机一次取数的区间内，
那么只需要取一次就可以了。如果不对齐??，很不巧，这个int数据刚好跨越了取数的边界，
这样就需要取两次才能把这个int的数据全部取到，这样效率也就降低了。


内存对齐是会浪费一些空间的。但是这种空间上得浪费却可以减少取数的时间。这是典型的一种以空间换时间的做法。
以下以GCC为例讲解结构体的对齐:

1.
typedef struct AA{

    char a;

    int b;

    char c; 

}aa

结果，sizeof（aa）= 12

简单的说，以int所占字节为准，使a和c所占的内存字节和int一致，同为4字节，所以最终为12字节；

一块连续的存储空间，编号为 0 - 11，char的字对齐长度为1，所以可以在任何地址开始，但是，int自对齐长度为4，必须以4的倍数地址开始。
所以，尽管 1-3 空着，但 b 也只能从 4 开始。再加上 c 后，整个结构体的总长度为9，结构体的有效对齐值为其中最大的成员即int的长度4，
所以，结构体的大小向上扩展到12，即9-11的地址空着。

2.
typedef struct AA{
    char a;
    char c; 
    int b;    
}aa

结果，sizeof（aa）= 8

简单的说，a与c总共只需2字节内存，那么为a与c分配一块4字节的内存，a与c存储在其中，以保证与int对其，所以总共占8字节


总结例子1 和例子 2，结论：结构体成员定义的顺序，会影响到整个结构体的所占的内存大小

3.
#pragma pack(2)
typedef struct AA{
    char a;
    int b;
    char c; 
}aa

结果，sizeof（aa）=10,

先为a分配空间，为了与int对其，所以分配4字节空间，为b分配空间后，总共分配了8字节，而c本身只占一个字节，所以总共只占9字节长度；
因为结构体的有效对齐长度在pack指定的2和int的4中取较小的值2。故取2的倍数，10。
同理，如果当pack指定为8，那就取较小的4，按4字节来对齐，结果与例子1一样，仍然是12

4.
typedef struct AA{
    char a;
    int b;
    char c; 
}__attribute__((__8__))aa

结果，sizeof(aa)=16，

其实a到c仍然只占9字节长度，但结构体以8对齐，故取8的倍数16，如果其指定2，则结果为10


如果pragma pack和__attribute__同时指定，则以__attribute__ 的为准


需要说明的是，不管pragma
 pack和__attribute__如何指定，结构体内部成员的自对齐仍然按照其自身的对齐值。


另外，不同的编译器可能会对内存的分布进行优化，例如有些编译器会把例子1中的程序优化成例题2的样子。

