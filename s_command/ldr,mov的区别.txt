ARM立即数，LDR和MOV的区别      

mov 指令将立即数写入寄存器，或从寄存器写入另一寄存器。
当mov 把立即数赋给一个寄存器，对立即数的范围有要求。只能是由8bit连续有效位通过偶数次移位能得到的数。
mov 本身就是一条32bit指令，除了指令码本身，它不可能再带一个可以表示32bit的数字，所以用了其中的12bit来表示立即数，
其中4bit表示移位的位数(循环右移，且数值x2)，8bit用来表示要移位的一个基数。
如下：
mov R0，#0x101
mov R0,#0xFF1
以上两条指令都不正确，因为立即数不合法。两个立即数都无法通过一个8bit的数循环右移得到
再如：
mov r0, #0x56000000
上条指令则是正确的，因为该立即数可以通过8bit的数，循环右移得到，即56循环右移8次得到

ldr 除了有给寄存器赋立即数的功能外，还可以用作从内存读数据到寄存器  
你只要写 ldr r0, =0xabcdef   它没有立即数范围的限制。因为这是一条伪指令。

如果立即数在mov 的要求内，那就用一条汇编来实现。如果不在mov 的范围内，就用其它方式实现，如变成两条指令，
或从PC偏移地址读一个32位数给寄存器。   


而且如果这个立即数可以用mov 指令的形式来表达，会被编译器实际用mov 来代替 
比如： 
ldr r1,=0x10 
会变成  
mov r1,#0x10    

ARM是RISC结构，数据从内存到CPU之间的移动只能通过L/S指令来完成，也就是ldr/str指令。
想把数据从内存中某处读取到寄存器中，只能使用ldr。

比如：   
ldr r0, 0x12345678   
就是把0x12345678这个地址中的值存放到r0中。   
而mov不能干这个活，mov只能在寄存器之间移动数据，或者把立即数移动到寄存器中，
这个和x86这种CISC架构的芯片区别最大的地方。 
x86中没有ldr这种指令，因为x86的mov指令可以将数据从内存中移动到寄存器中。 

另外还有一个就是ldr伪指令，虽然ldr伪指令和ARM的ldr指令很像，但是作用不太一样。
ldr伪指令可以在立即数前加上=，以表示把一个地址写到某寄存器中，
比如：   
ldr r0, =0x12345678   
这样，就把0x12345678这个地址写到r0中了。

所以，ldr伪指令和mov是比较相似的。只不过mov指令限制了立即数的长度为8位，也就是不能超过512。
而ldr伪指令没有这个限制。如果使用ldr伪指令时，后面跟的立即数没有超过 8位，
那么在实际汇编的时候该ldr伪指令是被转换为mov指令的。

ldr伪指令和ldr指令不是一个同东西，也就是说，ldr即可以是指令，也可以是伪指令
当ldr 前面有 = 号，表示伪指令，否则表示内存访问指令


