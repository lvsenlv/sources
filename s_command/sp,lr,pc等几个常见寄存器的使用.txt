arm汇编基础（转）


先看个例子：
void test2(int a,int b,int c)
{ 
int k=a,j=b,m=c;

}
GCC反汇编：
00000064 <test2>:
mov     ip, sp                  //IP=SP;保存SP
stmdb   sp!, {fp, ip, lr, pc}   //先对SP减4，再对fp，ip，lr，pc压栈。---------1
sub     fp, ip, #4      ; 0x4   //fp=ip-4；此时fp指向栈里面的“fp”
sub     sp, sp, #24     ; 0x18 //分配空间
str     r0, [fp, #-28]          //
str     r1, [fp, #-32]          //
str     r2, [fp, #-36]          //参数压栈
ldr     r3, [fp, #-28]          //
str     r3, [fp, #-24]          //
ldr     r3, [fp, #-32]          //
str     r3, [fp, #-20]          //
ldr     r3, [fp, #-36]          //
str     r3, [fp, #-16]          //
sub     sp, fp, #12     ; 0xc   //sp=fp-12；此时sp指向栈里面的lr
ldmia   sp, {fp, sp, pc}        //弹栈pc=lr，sp=ip，fp=fp。然后地址加4---------1
汇编基础：
stmdb   sp!, {fp, ip, lr, pc} //sp=sp-4,sp=pc;先压PC
                              //sp=sp-4,sp=lr;再压lr
                              //sp=sp-4,sp=ip;再压ip
                              //sp=sp-4,sp=fp;再压fp
ldmia   sp, {fp, sp, pc}      //和stmdb成对使用，
                              //fp=sp,sp=sp+4;先弹fp
                              //sp=sp,sp=sp+4;先弹sp，此处的弹出不会影响sp，因为ldmia是一个机器周期执行完的。
                              //pc=sp,sp=sp+4;先弹pc
LDRH          R0, [R13, #0xC] //加载无符号半字数据，即低16位
LDRB          R0, [R13, #0x4] //加载一字节数据，即低8位。
注意：R11=fp;R12=ip;R13=SP；R14=LR；R15=PC；R0,R1,R2用于传递参数和存放函数返回值。
注意；低地址的寄存器被压入低地址内存中，也就是说如果向下增长，高地址寄存器先压，向上增长测试低地址先压。 
注意：根据“ARM-thumb 过程调用标准”：
1， r0-r3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。---如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。
2， r4-r11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。
3， r12 是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。
4，寄存器 r13 是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。
5，寄存器 r14 是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复
6，寄存器 r15 是程序计数器 PC。它不能用于任何其它用途。
7，在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11，所以一般你自己只要在程序的开头
sub lr,lr,#4
stmfd sp!,{r0-r3,r12,lr}；保护R0～R3，R12,LR就可以了，除非你用汇编人为的去改变R4~R11的值。（具体去看UCOS os_cpu_a.S中的IRQ中断的代码）
补充：
寄存器名字
Reg # APCS 意义
R0 a1 工作寄存器
R1 a2 "
R2 a3 "
R3 a4 "
R4 v1 必须保护
R5 v2 "
R6 v3 "
R7 v4 "
R8 v5 "
R9 v6 "
R10 sl 栈限制
R11 fp 桢指针
R12 ip 
R13 sp 栈指针
R14 lr 连接寄存器
R15 pc 程序计数器
回溯结构
寄存器 fp (桢指针)应当是零或者是指向栈回溯结构的列表中的最后一个结构，提供了一种追溯程序的方式，来反向跟踪调用的函数。
回溯结构是:
地址高端
   保存代码指针        [fp]         fp 指向这里
   返回 lr 值          [fp, #-4]
   返回 sp 值          [fp, #-8]
   返回 fp 值          [fp, #-12] 指向下一个结构
   [保存的 sl]
   [保存的 v6]
   [保存的 v5]
   [保存的 v4]
   [保存的 v3]
   [保存的 v2]
   [保存的 v1]
   [保存的 a4]
   [保存的 a3]
   [保存的 a2]
   [保存的 a1]
   [保存的 f7]                          三个字
   [保存的 f6]                          三个字
   [保存的 f5]                          三个字
   [保存的 f4]                          三个字
pc 总是包含下一个要被执行的指令的位置。 
lr (总是)包含着退出时要装载到 pc 中的值。在 26-bit 位代码中它还包含着 PSR。 
sp 指向当前的栈块(chunk)限制，或它的上面。这是用于复制临时数据、寄存器和类似的东西到其中的地方。在 RISC OS 下，你有可选择的至少 256 字节来扩展它。 
fp 要么是零，要么指向回溯结构的最当前的部分。
